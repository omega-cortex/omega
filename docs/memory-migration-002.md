# Developer Guide: Migration 002 -- Audit Log

## Path

`crates/omega-memory/migrations/002_audit_log.sql`

## Overview

Migration 002 creates the `audit_log` table, which records every interaction that flows through the Omega gateway. Every time a user sends a message -- whether it gets a successful response, triggers an error, or is denied by the auth layer -- the gateway writes a row to this table. The audit log is the system's complete activity record and is independent of the conversation memory created in migration 001.

This guide covers what the migration creates, how the audit log fits into Omega's architecture, and what developers need to know when working with it.

## What This Migration Creates

The migration contains three SQL statements:

1. **`audit_log` table** -- A 12-column table that stores one row per interaction.
2. **`idx_audit_log_timestamp` index** -- Speeds up time-based queries.
3. **`idx_audit_log_sender` index** -- Speeds up per-user, per-channel queries.

All three use `IF NOT EXISTS`, making the migration safe to run multiple times.

## Where It Fits in the Migration Sequence

Omega's SQLite database is built up incrementally by three migrations:

| Migration | What it does |
|-----------|-------------|
| `001_init.sql` | Creates the core memory tables: `conversations`, `messages`, and `facts`. These store conversation history and extracted knowledge. |
| **`002_audit_log.sql`** | **Creates the `audit_log` table. This is a separate, independent record of all gateway activity.** |
| `003_memory_enhancement.sql` | Enhances `conversations` with summaries, activity tracking, and status. Recreates `facts` with per-sender scoping. |

The audit log has no foreign keys to the conversation tables. This is intentional -- the audit log records interactions that may never produce conversation records (like denied requests), and it should survive any future conversation pruning or cleanup operations.

## Schema Overview

```
audit_log
+------------------+----------+-----------+-----------------------------------+
| Column           | Type     | Required  | Notes                             |
+------------------+----------+-----------+-----------------------------------+
| id               | TEXT     | PK        | UUID v4, generated by Rust code   |
| timestamp        | TEXT     | NOT NULL  | Auto-set to current UTC datetime  |
| channel          | TEXT     | NOT NULL  | "telegram", "whatsapp", "cli"     |
| sender_id        | TEXT     | NOT NULL  | Platform-specific user ID         |
| sender_name      | TEXT     | nullable  | Display name if available         |
| input_text       | TEXT     | NOT NULL  | The user's message                |
| output_text      | TEXT     | nullable  | The provider's response           |
| provider_used    | TEXT     | nullable  | "claude-code", "anthropic", etc.  |
| model            | TEXT     | nullable  | Model ID from the provider        |
| processing_ms    | INTEGER  | nullable  | Wall-clock processing time        |
| status           | TEXT     | NOT NULL  | "ok", "error", or "denied"        |
| denial_reason    | TEXT     | nullable  | Why the request was denied         |
+------------------+----------+-----------+-----------------------------------+

Indexes:
  idx_audit_log_timestamp  -> (timestamp)
  idx_audit_log_sender     -> (channel, sender_id)
```

## The Status Field

The `status` column is constrained by a `CHECK` constraint to exactly three values:

- **`ok`** -- The provider processed the request and returned a response. This is the default value in the schema, though the Rust code always sets it explicitly.
- **`error`** -- The provider was invoked but something went wrong (timeout, API error, malformed response).
- **`denied`** -- The auth layer rejected the request before it reached any provider. When this happens, `provider_used`, `model`, `processing_ms`, and `output_text` are all `NULL`, and `denial_reason` explains why.

These values correspond to the `AuditStatus` enum in `crates/omega-memory/src/audit.rs`.

## Why Some Columns Are Nullable

The nullable columns reflect different interaction outcomes:

**Successful request (`status = 'ok'`):** All columns except `sender_name` and `denial_reason` will have values. `sender_name` may be `NULL` if the platform does not provide display names.

**Error during processing (`status = 'error'`):** `provider_used` and `processing_ms` will have values (the provider was invoked), but `output_text` and `model` may be `NULL` if the provider failed before producing output.

**Denied request (`status = 'denied'`):** Only `channel`, `sender_id`, `input_text`, `status`, and `denial_reason` will have values. Everything provider-related is `NULL` because the request never reached a provider.

## How the Audit Log Is Written

The `AuditLogger` struct in `crates/omega-memory/src/audit.rs` is responsible for all writes. Here is the flow:

```
User sends message
        |
        v
Gateway receives IncomingMessage
        |
        v
Auth check (allowed_users)
        |
   +----+----+
   |         |
  PASS     DENY --> AuditLogger.log(status: denied, denial_reason: "...")
   |
   v
Provider.complete(context)
   |
   +----+----+
   |         |
  OK      ERROR --> AuditLogger.log(status: error)
   |
   v
AuditLogger.log(status: ok, output_text: "...", processing_ms: 142)
```

The gateway calls `AuditLogger::log()` exactly once per interaction, after the outcome is determined. The `AuditEntry` struct passed to `log()` mirrors the table columns:

```rust
pub struct AuditEntry {
    pub channel: String,
    pub sender_id: String,
    pub sender_name: Option<String>,
    pub input_text: String,
    pub output_text: Option<String>,
    pub provider_used: Option<String>,
    pub model: Option<String>,
    pub processing_ms: Option<i64>,
    pub status: AuditStatus,
    pub denial_reason: Option<String>,
}
```

The `id` column is not in the struct -- it is generated inside `log()` as a UUID v4. The `timestamp` column is not bound either -- SQLite's `DEFAULT (datetime('now'))` fills it automatically.

## Querying the Audit Log

The two indexes support the most common query patterns.

### Recent activity (uses `idx_audit_log_timestamp`)

```sql
SELECT * FROM audit_log
ORDER BY timestamp DESC
LIMIT 50;
```

### Activity for a specific user on a specific channel (uses `idx_audit_log_sender`)

```sql
SELECT * FROM audit_log
WHERE channel = 'telegram' AND sender_id = '123456789'
ORDER BY timestamp DESC;
```

### All denied requests (uses `idx_audit_log_timestamp` for ordering)

```sql
SELECT timestamp, channel, sender_id, input_text, denial_reason
FROM audit_log
WHERE status = 'denied'
ORDER BY timestamp DESC;
```

### Average processing time by provider (full table scan)

```sql
SELECT provider_used, AVG(processing_ms) as avg_ms, COUNT(*) as total
FROM audit_log
WHERE status = 'ok' AND processing_ms IS NOT NULL
GROUP BY provider_used;
```

Note: There is no index on `status` or `provider_used`. If these queries become frequent at scale, adding indexes would be worthwhile. For the typical single-user Omega deployment, the current indexes are sufficient.

## Relationship to Conversation Memory

The audit log and the conversation memory (`conversations` + `messages` tables from migration 001) serve different purposes:

| Aspect | Conversation Memory | Audit Log |
|--------|-------------------|-----------|
| Purpose | Build context for the AI provider | Record all activity for review and debugging |
| Scope | Only successful user/assistant exchanges | Every interaction including errors and denials |
| Linked | Messages belong to conversations (FK) | Standalone rows with no FKs |
| Used at runtime | Yes -- context is built from recent messages | No -- write-only during normal operation |
| Prunable | Yes -- old conversations can be summarized/archived | Should be retained as a complete record |

A single successful interaction produces:
- One row in `messages` (the user message)
- One row in `messages` (the assistant response)
- One row in `audit_log` (the complete interaction record)

A denied interaction produces:
- Zero rows in `messages`
- One row in `audit_log` (with `status = 'denied'`)

## Error Handling

All audit log writes go through `AuditLogger::log()`, which maps SQLite errors to `OmegaError::Memory("audit log write failed: ...")`. If the audit write fails (e.g., disk full, database locked), the error propagates up to the gateway. The gateway logs the error but does not retry audit writes -- the response to the user has already been sent by this point.

## Adding New Columns

If you need to record additional information in the audit log:

1. Create a new migration file (e.g., `004_audit_enhancement.sql`) with an `ALTER TABLE audit_log ADD COLUMN ...` statement. New columns should be nullable or have defaults so existing rows are not affected.
2. Update the `AuditEntry` struct in `crates/omega-memory/src/audit.rs` with the new field.
3. Update the `INSERT INTO` query in `AuditLogger::log()` to bind the new column.
4. Update the gateway code that constructs `AuditEntry` to populate the new field.
5. Run `cargo check --workspace` to verify compilation.

Do **not** modify `002_audit_log.sql` directly. Migrations are applied in order and existing databases have already run this migration. Schema changes must go in new migration files.

## Summary

Migration 002 establishes the audit log as Omega's activity record. It captures every interaction -- successful, failed, or denied -- in a single flat table with two indexes for efficient time-based and user-based queries. The table is independent of the conversation memory system, ensuring that the audit trail is complete and resilient to conversation cleanup operations. The `AuditLogger` in the Rust codebase handles all writes, generating UUIDs for each entry and relying on SQLite defaults for timestamps.
