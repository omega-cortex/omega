# Specification: Migration 002 -- Audit Log

## Path

`crates/omega-memory/migrations/002_audit_log.sql`

## Purpose

Creates the `audit_log` table and its supporting indexes. This table records every interaction that passes through the Omega gateway -- successful completions, errors, and denied requests. It provides a complete, immutable record of who asked what, which provider answered, how long it took, and whether the request succeeded, failed, or was rejected by auth.

This is the second migration in the `omega-memory` migration sequence, following `001_init.sql` (which creates `conversations`, `messages`, and `facts`) and preceding `003_memory_enhancement.sql` (which adds conversation boundaries and sender-scoped facts).

## Migration Sequence Context

| Order | File | Creates |
|-------|------|---------|
| 001 | `001_init.sql` | `conversations`, `messages`, `facts` tables |
| **002** | **`002_audit_log.sql`** | **`audit_log` table** |
| 003 | `003_memory_enhancement.sql` | Alters `conversations`, recreates `facts` with sender scoping |

## Full SQL

```sql
-- Audit log: every interaction through Omega

CREATE TABLE IF NOT EXISTS audit_log (
    id              TEXT PRIMARY KEY,
    timestamp       TEXT NOT NULL DEFAULT (datetime('now')),
    channel         TEXT NOT NULL,
    sender_id       TEXT NOT NULL,
    sender_name     TEXT,
    input_text      TEXT NOT NULL,
    output_text     TEXT,
    provider_used   TEXT,
    model           TEXT,
    processing_ms   INTEGER,
    status          TEXT NOT NULL DEFAULT 'ok' CHECK (status IN ('ok', 'error', 'denied')),
    denial_reason   TEXT
);

CREATE INDEX IF NOT EXISTS idx_audit_log_timestamp ON audit_log(timestamp);
CREATE INDEX IF NOT EXISTS idx_audit_log_sender ON audit_log(channel, sender_id);
```

---

## CREATE TABLE: `audit_log`

### Statement

```sql
CREATE TABLE IF NOT EXISTS audit_log ( ... );
```

The `IF NOT EXISTS` guard makes the migration idempotent -- running it multiple times against the same database will not fail or duplicate the table.

### Column Definitions

| Column | SQLite Type | Nullable | Default | Constraints | Description |
|--------|-------------|----------|---------|-------------|-------------|
| `id` | `TEXT` | NOT NULL | None (caller-supplied) | `PRIMARY KEY` | UUID v4 generated by the Rust `AuditLogger` before insertion. |
| `timestamp` | `TEXT` | NOT NULL | `datetime('now')` | -- | ISO 8601 timestamp in UTC. Auto-populated by SQLite if the caller omits it. The Rust code does not bind this column, relying on the default. |
| `channel` | `TEXT` | NOT NULL | None | -- | Identifies the messaging platform that received the message (e.g., `"telegram"`, `"whatsapp"`, `"cli"`). |
| `sender_id` | `TEXT` | NOT NULL | None | -- | Platform-specific user identifier (e.g., Telegram numeric user ID as a string). |
| `sender_name` | `TEXT` | NULL | `NULL` | -- | Human-readable display name for the sender, if available. Optional because not all platforms expose names. |
| `input_text` | `TEXT` | NOT NULL | None | -- | The full user message as received by the gateway. |
| `output_text` | `TEXT` | NULL | `NULL` | -- | The provider's response. `NULL` when the request was denied before reaching the provider, or when the provider returned an error with no usable output. |
| `provider_used` | `TEXT` | NULL | `NULL` | -- | Which AI provider handled the request (e.g., `"claude-code"`, `"anthropic"`, `"openai"`). `NULL` when the request was denied before provider dispatch. |
| `model` | `TEXT` | NULL | `NULL` | -- | The specific model identifier returned by the provider (e.g., `"claude-sonnet-4-20250514"`). `NULL` when no provider was invoked. |
| `processing_ms` | `INTEGER` | NULL | `NULL` | -- | Wall-clock milliseconds from receiving the message to producing a response. `NULL` when no processing occurred (denied requests). |
| `status` | `TEXT` | NOT NULL | `'ok'` | `CHECK (status IN ('ok', 'error', 'denied'))` | Outcome of the interaction. Constrained to exactly three values. |
| `denial_reason` | `TEXT` | NULL | `NULL` | -- | Explanation when `status = 'denied'` (e.g., `"user not in allowed_users list"`). `NULL` for successful and errored requests. |

### Primary Key

The primary key is the `id` column, a UUID v4 string generated by the application layer (`uuid::Uuid::new_v4().to_string()`). SQLite does not auto-generate this value -- the Rust code must supply it on every insert.

### CHECK Constraint

```sql
CHECK (status IN ('ok', 'error', 'denied'))
```

This enforces a closed enum at the database level. The three permitted values correspond to the `AuditStatus` Rust enum in `crates/omega-memory/src/audit.rs`:

| SQL Value | Rust Variant | Meaning |
|-----------|-------------|---------|
| `'ok'` | `AuditStatus::Ok` | The provider successfully processed the request and returned a response. |
| `'error'` | `AuditStatus::Error` | The provider was invoked but returned an error or the processing pipeline failed. |
| `'denied'` | `AuditStatus::Denied` | The auth layer rejected the request before it reached the provider. |

Any attempt to insert a row with a `status` value outside this set will result in a SQLite constraint violation.

### Default Values

Two columns have server-side defaults:

| Column | Default Expression | Notes |
|--------|-------------------|-------|
| `timestamp` | `datetime('now')` | SQLite function that returns the current UTC datetime as an ISO 8601 string (e.g., `"2025-06-15 14:30:00"`). The Rust `AuditLogger.log()` method does not bind this column, so every row gets the insertion timestamp automatically. |
| `status` | `'ok'` | The most common outcome. The Rust code always binds this column explicitly (via `AuditStatus::as_str()`), so the default is a safety net rather than a relied-upon behavior. |

### Foreign Keys

The `audit_log` table has **no foreign key constraints**. This is a deliberate design decision:

- The audit log is independent of the conversation/message tables created in `001_init.sql`. An audit entry records the raw interaction (input/output text, timing, status) without linking to specific conversation or message rows.
- This independence means the audit log can record denied requests and errors that never produce conversation or message records.
- It also means the audit log cannot be corrupted by cascading deletes or conversation pruning operations.

### Nullable Column Semantics

The nullable columns follow a pattern dictated by the interaction lifecycle:

| Scenario | `sender_name` | `output_text` | `provider_used` | `model` | `processing_ms` | `denial_reason` |
|----------|--------------|---------------|-----------------|---------|-----------------|-----------------|
| Successful completion | May have value | Has value | Has value | Has value | Has value | `NULL` |
| Provider error | May have value | May have value | Has value | May have value | Has value | `NULL` |
| Auth denial | May have value | `NULL` | `NULL` | `NULL` | `NULL` | Has value |

---

## Indexes

### `idx_audit_log_timestamp`

```sql
CREATE INDEX IF NOT EXISTS idx_audit_log_timestamp ON audit_log(timestamp);
```

| Property | Value |
|----------|-------|
| Name | `idx_audit_log_timestamp` |
| Table | `audit_log` |
| Columns | `timestamp` |
| Unique | No |
| Conditional | `IF NOT EXISTS` (idempotent) |

**Purpose:** Accelerates queries that filter or sort by time. Common use cases include "show all interactions in the last 24 hours" and "find the most recent N entries." Since `timestamp` stores ISO 8601 text, lexicographic ordering is equivalent to chronological ordering, making B-tree index scans efficient.

### `idx_audit_log_sender`

```sql
CREATE INDEX IF NOT EXISTS idx_audit_log_sender ON audit_log(channel, sender_id);
```

| Property | Value |
|----------|-------|
| Name | `idx_audit_log_sender` |
| Table | `audit_log` |
| Columns | `channel`, `sender_id` (composite) |
| Unique | No |
| Conditional | `IF NOT EXISTS` (idempotent) |

**Purpose:** Accelerates queries that filter by a specific user on a specific channel. The composite index covers the common pattern of "show all interactions from sender X on Telegram." The column order (`channel` first, `sender_id` second) means the index also supports queries that filter by channel alone (leftmost prefix optimization), but not queries that filter by `sender_id` alone without specifying `channel`.

---

## Rust Integration

### Writer: `AuditLogger`

The audit log is written by `AuditLogger` in `crates/omega-memory/src/audit.rs`. The `log()` method:

1. Generates a UUID v4 for the `id` column.
2. Binds all 11 explicit columns (excluding `timestamp`, which uses its default).
3. Executes a single `INSERT INTO audit_log` statement.
4. Emits a `debug!` trace with a truncated preview of the input text.
5. Maps any SQLite error to `OmegaError::Memory("audit log write failed: ...")`.

### Caller: Gateway Event Loop

The gateway (`src/gateway.rs`) calls `AuditLogger::log()` after every interaction, regardless of outcome:

- After a successful provider completion (status `ok`)
- After a provider error (status `error`)
- After an auth denial (status `denied`)

This ensures the audit log is a complete record of all activity, not just successes.

### Data Types: Rust to SQL Mapping

| Rust Field (`AuditEntry`) | Rust Type | SQL Column | SQL Type |
|--------------------------|-----------|------------|----------|
| (generated) | `String` (UUID v4) | `id` | `TEXT` |
| (omitted -- uses default) | -- | `timestamp` | `TEXT` |
| `channel` | `String` | `channel` | `TEXT` |
| `sender_id` | `String` | `sender_id` | `TEXT` |
| `sender_name` | `Option<String>` | `sender_name` | `TEXT` (nullable) |
| `input_text` | `String` | `input_text` | `TEXT` |
| `output_text` | `Option<String>` | `output_text` | `TEXT` (nullable) |
| `provider_used` | `Option<String>` | `provider_used` | `TEXT` (nullable) |
| `model` | `Option<String>` | `model` | `TEXT` (nullable) |
| `processing_ms` | `Option<i64>` | `processing_ms` | `INTEGER` (nullable) |
| `status` | `AuditStatus` | `status` | `TEXT` (CHECK constrained) |
| `denial_reason` | `Option<String>` | `denial_reason` | `TEXT` (nullable) |

---

## Idempotency

All three statements in this migration use `IF NOT EXISTS`:

- `CREATE TABLE IF NOT EXISTS audit_log` -- skips table creation if it already exists.
- `CREATE INDEX IF NOT EXISTS idx_audit_log_timestamp` -- skips index creation if it already exists.
- `CREATE INDEX IF NOT EXISTS idx_audit_log_sender` -- skips index creation if it already exists.

This means the migration can be safely re-run against a database that has already been migrated without causing errors or data loss.

---

## Summary Table

| Aspect | Detail |
|--------|--------|
| File | `crates/omega-memory/migrations/002_audit_log.sql` |
| Migration number | 002 |
| Tables created | 1 (`audit_log`) |
| Columns | 12 |
| NOT NULL columns | 5 (`id`, `timestamp`, `channel`, `sender_id`, `input_text`, `status`) |
| Nullable columns | 6 (`sender_name`, `output_text`, `provider_used`, `model`, `processing_ms`, `denial_reason`) |
| CHECK constraints | 1 (`status IN ('ok', 'error', 'denied')`) |
| Default values | 2 (`timestamp`, `status`) |
| Foreign keys | 0 |
| Indexes created | 2 (`idx_audit_log_timestamp`, `idx_audit_log_sender`) |
| Idempotent | Yes (all statements use `IF NOT EXISTS`) |
| Rust writer | `AuditLogger` in `crates/omega-memory/src/audit.rs` |
| Lines of SQL | 20 |
