# Specification: omega-core Error Types

## Path
`crates/omega-core/src/error.rs`

## Purpose
Defines `OmegaError`, the single top-level error enum for the entire Omega workspace. Every fallible operation across all six crates returns `Result<T, OmegaError>`, giving the system a unified error type that flows from the deepest storage call all the way up to the gateway event loop and CLI commands.

## Dependencies
- **thiserror** -- derive macro for `std::error::Error` and `Display` implementations
- **std::io::Error** -- automatic conversion via `#[from]`
- **serde_json::Error** -- automatic conversion via `#[from]`

## Enum Definition

```rust
#[derive(Debug, Error)]
pub enum OmegaError {
    #[error("provider error: {0}")]
    Provider(String),

    #[error("channel error: {0}")]
    Channel(String),

    #[error("config error: {0}")]
    Config(String),

    #[error("memory error: {0}")]
    Memory(String),

    #[error("sandbox error: {0}")]
    Sandbox(String),

    #[error("io error: {0}")]
    Io(#[from] std::io::Error),

    #[error("serialization error: {0}")]
    Serialization(#[from] serde_json::Error),
}
```

## Variant Reference

| Variant | Inner Type | Display Format | `From` impl | Primary Crate(s) |
|---------|-----------|----------------|-------------|-------------------|
| `Provider(String)` | `String` | `provider error: {msg}` | Manual construction | `omega-providers` |
| `Channel(String)` | `String` | `channel error: {msg}` | Manual construction | `omega-channels` |
| `Config(String)` | `String` | `config error: {msg}` | Manual construction | `omega-core` (config module) |
| `Memory(String)` | `String` | `memory error: {msg}` | Manual construction | `omega-memory` |
| `Sandbox(String)` | `String` | `sandbox error: {msg}` | Manual construction | `omega-sandbox` (planned) |
| `Io(std::io::Error)` | `std::io::Error` | `io error: {err}` | `#[from]` auto | Any crate performing I/O |
| `Serialization(serde_json::Error)` | `serde_json::Error` | `serialization error: {err}` | `#[from]` auto | Any crate doing JSON ser/de |

## Trait Implementations

### `std::fmt::Debug`
Derived via `#[derive(Debug)]`. Outputs the enum variant name and its inner value in debug format.

### `std::fmt::Display`
Generated by `thiserror`'s `#[error("...")]` attribute on each variant. Every variant produces a human-readable string with a domain prefix (e.g., `provider error: ...`, `memory error: ...`).

### `std::error::Error`
Derived via `thiserror::Error`. Provides:
- `source()` -- returns `Some(&inner)` for `Io` and `Serialization` (wrapping foreign errors); returns `None` for all `String`-based variants.
- Automatic `Display` delegation.

### `From` Conversions

Two automatic conversions are generated by `#[from]`:

| Source Type | Target Variant | Usage Pattern |
|-------------|---------------|---------------|
| `std::io::Error` | `OmegaError::Io(e)` | `?` operator on any `std::io` call |
| `serde_json::Error` | `OmegaError::Serialization(e)` | `?` operator on `serde_json::to_string` / `serde_json::from_str` |

All other variants (`Provider`, `Channel`, `Config`, `Memory`, `Sandbox`) require explicit construction via `.map_err()` because they carry a `String`, not a typed foreign error.

## Error Propagation Through the System

### Trait Signatures
`OmegaError` is the error type in every core trait method signature:

```rust
// Provider trait (omega-core/src/traits.rs)
async fn complete(&self, context: &Context) -> Result<OutgoingMessage, OmegaError>;

// Channel trait (omega-core/src/traits.rs)
async fn start(&self) -> Result<mpsc::Receiver<IncomingMessage>, OmegaError>;
async fn send(&self, message: OutgoingMessage) -> Result<(), OmegaError>;
async fn send_typing(&self, _target: &str) -> Result<(), OmegaError>;
async fn stop(&self) -> Result<(), OmegaError>;
```

### Propagation Path
The error flows upward through the architecture:

```
SQLite / HTTP / I/O failure
    |
    v
omega-memory / omega-channels / omega-providers
    |  (map_err to OmegaError::Memory / ::Channel / ::Provider)
    v
omega-core trait boundary (Result<T, OmegaError>)
    |  (? operator)
    v
src/gateway.rs event loop
    |  (logged via tracing, may retry or propagate)
    v
src/main.rs
    |  (converted to anyhow::Error for final display)
    v
User sees error message
```

### Construction Patterns by Crate

**omega-core (config module):**
```rust
.map_err(|e| OmegaError::Config(format!("failed to read {}: {}", path.display(), e)))?;
.map_err(|e| OmegaError::Config(format!("failed to parse config: {}", e)))?;
```

**omega-providers (claude_code module):**
```rust
.map_err(|e| OmegaError::Provider(format!("failed to run claude CLI: {e}")))?;
return Err(OmegaError::Provider(format!("claude exit code {}: {}", ...)));
```

**omega-channels (telegram module):**
```rust
.map_err(|e| OmegaError::Channel(format!("telegram send failed: {e}")))?;
.ok_or_else(|| OmegaError::Channel("no reply_target on outgoing message".into()))?;
OmegaError::Channel(format!("invalid telegram chat_id '{target}': {e}"))
```

**omega-memory (store and audit modules):**
```rust
.map_err(|e| OmegaError::Memory(format!("failed to connect to sqlite: {e}")))?;
.map_err(|e| OmegaError::Memory(format!("query failed: {e}")))?;
.map_err(|e| OmegaError::Memory(format!("audit log write failed: {e}")))?;
```

## Design Notes

1. **Single enum, no nesting.** There is one flat error type for the whole workspace. This avoids nested error enums and simplifies trait signatures.

2. **String-based domain variants.** Five of seven variants carry `String`. This means the original typed error is converted to a human-readable message at the point of failure. The trade-off: callers cannot programmatically match on the underlying error cause, but the message is always descriptive.

3. **Typed foreign-error variants.** `Io` and `Serialization` wrap the original error with `#[from]`, preserving the source chain and enabling `?` without `.map_err()`.

4. **No `#[non_exhaustive]`.** Adding new variants is a breaking change for downstream `match` arms. This is acceptable because all crates are in the same workspace.

5. **No error codes or error IDs.** Errors are identified by variant and message text, not by numeric codes.

6. **Gateway is the error boundary.** In the `omega start` flow, the gateway catches `OmegaError` from providers, channels, and memory, logs it, and decides whether to retry or propagate. The CLI `omega ask` flow propagates the error directly to `anyhow` for display.

## Usage Count by Variant

Approximate usage across the codebase (based on grep):

| Variant | Occurrences |
|---------|-------------|
| `Memory` | ~30 (store.rs, audit.rs) |
| `Channel` | ~8 (telegram.rs) |
| `Provider` | ~3 (claude_code.rs) |
| `Config` | ~2 (config.rs) |
| `Sandbox` | 0 (planned) |
| `Io` | 0 explicit (used via `?` auto-conversion) |
| `Serialization` | 0 explicit (used via `?` auto-conversion) |

## Re-export Path

The error module is declared public in `omega-core/src/lib.rs`:

```rust
pub mod error;
```

Other crates import it as:

```rust
use omega_core::error::OmegaError;
```

## Summary Table

| Aspect | Detail |
|--------|--------|
| File | `crates/omega-core/src/error.rs` |
| Type | `enum OmegaError` |
| Derive macros | `Debug`, `thiserror::Error` |
| Total variants | 7 |
| String-based variants | 5 (`Provider`, `Channel`, `Config`, `Memory`, `Sandbox`) |
| Typed-error variants | 2 (`Io`, `Serialization`) |
| `From` impls | `std::io::Error`, `serde_json::Error` |
| Consuming crates | `omega-providers`, `omega-channels`, `omega-memory`, `omega-core` (config) |
| Lines of code | 33 |
