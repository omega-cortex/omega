# OMEGA â€” Polish Phase: Make What Exists Superior

## Instructions for Claude Code

Do NOT add new features. Make what exists excellent. Omega has 2,284 lines and works. The goal is to make those lines the best 2,284 lines of any AI agent in existence.

Focus: Memory that actually works, conversation that feels natural, reliability that never fails.

---

## 1. Conversational Memory That Works Across Sessions

This is THE feature that makes Omega feel alive. When Ivan writes tomorrow "Â¿quÃ© hablamos ayer?", Omega must answer correctly.

### What to fix in `omega-memory/src/store.rs`:

**A. Context building must include conversation history intelligently:**

```rust
/// When building context for the provider, include:
/// 1. Last 10 messages from the CURRENT conversation (today)
/// 2. A summary line of the last 3 conversations (previous days)
/// 3. Any facts stored in the facts table
///
/// The system prompt sent to Claude Code should look like:
///
/// "You are Omega, a personal AI assistant.
///  
///  Previous conversations:
///  - Feb 15: Discussed building Omega agent in Rust, set up Telegram bot
///  - Feb 14: Worked on VidFormer causal rules
///  - Feb 13: Costco server migration planning
///
///  Known facts about the user:
///  - Name: Ivan
///  - Role: Systems administrator at Costco
///  - Prefers: Rust, direct communication, no unnecessary complexity
///
///  Current conversation:
///  [last 10 messages]"
```

**B. Conversation summarization on close:**

When a conversation has been idle for 30 minutes, generate a one-line summary and store it:

```rust
/// Add to conversations table:
///   summary TEXT  -- one-line summary generated when conversation goes idle
///
/// The summary is generated by asking Claude Code:
///   "Summarize this conversation in one line (max 100 chars): [messages]"
///
/// This is CHEAP: one short API call per conversation.
/// It enables "what did we talk about yesterday?" without loading full history.
```

**C. Facts extraction â€” simple version:**

After each conversation idle timeout, extract key facts:

```rust
/// Ask Claude Code:
///   "Extract any new factual information about the user from this conversation.
///    Return as simple key:value pairs, one per line. Only concrete facts.
///    If no new facts, return NONE.
///    Example: preferred_language:Rust
///    Example: working_on:Omega AI agent"
///
/// Store in the existing facts table.
/// On next conversation, include relevant facts in context.
/// This is the ONLY distillation needed right now. No triple stores,
/// no decay curves, no complexity. Just key:value facts.
```

### Migration: `003_memory_enhancement.sql`

```sql
-- Add summary column to conversations
ALTER TABLE conversations ADD COLUMN summary TEXT;

-- Add idle tracking
ALTER TABLE conversations ADD COLUMN last_activity TEXT;

-- Ensure facts table has what we need
-- (should already exist, but verify schema)
-- facts: id, key, value, source_message_id, created_at, updated_at
```

---

## 2. Conversation Management

### Auto-detect conversation boundaries:

```rust
/// A conversation is "active" if the last message was < 30 minutes ago.
/// After 30 minutes of silence:
///   1. Generate summary (one Claude Code call)
///   2. Extract facts (one Claude Code call)  
///   3. Mark conversation as closed
///   4. Next message starts a new conversation
///
/// This means context is always fresh and relevant.
/// Old conversations don't pollute current context.
```

### Implement in gateway.rs:

```rust
/// Add a background task that checks for idle conversations every 60 seconds.
/// When one is found idle > 30 min:
///   - Call summarize_conversation()
///   - Call extract_facts()
///   - Mark as closed
///
/// Use tokio::spawn for this â€” non-blocking, runs alongside the main loop.
```

---

## 3. Response Quality

### System prompt improvement:

The current system prompt is basic. Replace with:

```
You are Omega (Î©), a personal AI agent running on the owner's server.
You are NOT a chatbot. You are an agent that DOES things.

Your owner is Ivan â€” a systems administrator and computational researcher.
He values: directness, technical precision, no unnecessary fluff.

Rules:
- When asked to DO something, DO IT. Don't explain how â€” just do it.
- When asked a question, answer concisely. No preamble.
- You have access to the owner's system via Claude Code CLI tools.
- You remember past conversations. Reference them naturally when relevant.
- Speak the same language the owner uses. If they write in Spanish, respond in Spanish.
- Never say "I can't do that" without trying first.
- Never apologize unnecessarily.
- Be proactive: if you notice something relevant, mention it.

{facts_section}
{conversation_history_section}
```

### Language detection:

```rust
/// Detect the language of the incoming message and ensure the response
/// matches. This is critical for Ivan who writes in both English and Spanish.
/// 
/// Simple approach: if the message contains Spanish characters (Ã¡, Ã©, Ã­, Ã³, Ãº, Ã±, Â¿, Â¡)
/// or common Spanish words, add "Respond in Spanish." to the context.
/// Otherwise, let Claude Code auto-detect.
///
/// Do NOT use a library for this. A simple heuristic is enough:
fn likely_spanish(text: &str) -> bool {
    let spanish_indicators = ["Ã¡", "Ã©", "Ã­", "Ã³", "Ãº", "Ã±", "Â¿", "Â¡"];
    let spanish_words = ["hola", "quÃ©", "cÃ³mo", "para", "esto", "hacer", "quiero", "necesito", "dame", "dime"];
    
    let lower = text.to_lowercase();
    spanish_indicators.iter().any(|c| lower.contains(c))
        || spanish_words.iter().any(|w| lower.contains(w))
}
```

---

## 4. Reliability â€” Never Drop a Message

### Telegram resilience:

```rust
/// Current implementation uses long polling. Make it bulletproof:
///
/// A. Retry logic: if getUpdates fails, retry with exponential backoff
///    (1s, 2s, 4s, 8s, max 60s). Log each retry. Never crash.
///
/// B. Graceful degradation: if Claude Code CLI is slow or fails,
///    send a "â³ Processing..." message immediately, then send the
///    real response when ready. The user should never wonder if
///    the bot is alive.
///
/// C. Long response handling: if Claude Code takes > 10 seconds,
///    send a typing indicator via Telegram's sendChatAction API.
///    This shows "Omega is typing..." in the chat.
///
/// D. Error recovery: if the provider fails, don't send raw error text.
///    Send: "âš ï¸ Couldn't process that. Try again in a moment."
///    Log the full error internally.
```

### Implement typing indicator:

```rust
/// POST https://api.telegram.org/bot{token}/sendChatAction
/// Body: { "chat_id": chat_id, "action": "typing" }
///
/// Call this BEFORE sending the message to the provider.
/// It tells Telegram to show "typing..." for 5 seconds.
/// If the response takes longer, call it again every 5 seconds.
```

### Startup self-check:

```rust
/// On `omega start`, before accepting any messages:
/// 1. Verify SQLite database is accessible and migrated
/// 2. Verify Claude Code CLI is available and authenticated
/// 3. Verify Telegram bot token is valid (call getMe API)
/// 4. Log all results clearly:
///    "Î© Omega starting..."
///    "  âœ“ Database: ~/.omega/memory.db (4 tables, 3 conversations)"
///    "  âœ“ Provider: claude-code (Claude Code CLI v1.x)"
///    "  âœ“ Channel: telegram (bot: @omega_agent_bot)"
///    "  Î© Ready. Listening..."
///
/// If any check fails, print exactly what's wrong and exit.
/// Never start in a broken state.
```

---

## 5. Commands That Actually Help

### Built-in commands (handle in gateway, don't send to provider):

```
/status  â†’ Show agent status: uptime, provider, memory stats, chain health
/memory  â†’ Show memory stats: conversations count, facts count, db size
/forget  â†’ Clear current conversation context (start fresh)
/facts   â†’ List all known facts about the owner
/history â†’ List last 5 conversation summaries with dates
/help    â†’ List available commands
```

### Implementation:

```rust
/// In gateway.rs, before sending to provider, check for commands:
///
/// if incoming.text.starts_with('/') {
///     match incoming.text.as_str() {
///         "/status" => return self.handle_status().await,
///         "/memory" => return self.handle_memory().await,
///         "/forget" => return self.handle_forget(&incoming).await,
///         "/facts" => return self.handle_facts().await,
///         "/history" => return self.handle_history().await,
///         "/help" => return self.handle_help().await,
///         _ => {} // Unknown command, pass to provider
///     }
/// }
///
/// These commands are INSTANT â€” no provider call needed.
/// They query SQLite directly and format the response.
```

### /status response format:

```
Î© Omega Status
â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â± Uptime: 3h 42m
ğŸ¤– Provider: claude-code (healthy)
ğŸ’¬ Conversations: 12 (3 today)
ğŸ§  Facts: 28
ğŸ“Š Messages processed: 47
ğŸ’¾ Database: 1.2 MB
```

### /history response format:

```
ğŸ“œ Recent Conversations
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ Today 6:01 AM â€” Set up Omega bot and LaunchAgent
â€¢ Feb 15, 9:30 PM â€” Discussed Omega architecture and naming
â€¢ Feb 15, 3:15 PM â€” VidFormer causal rules debugging
â€¢ Feb 14, 11:00 AM â€” Costco Puppet Enterprise migration
â€¢ Feb 13, 8:45 PM â€” DOLI consensus mechanism review
```

---

## 6. Clean Startup and Shutdown

### Graceful shutdown on SIGTERM/SIGINT:

```rust
/// Handle ctrl+C and system shutdown signals:
/// 1. Stop accepting new messages
/// 2. Finish processing current message (with 10s timeout)
/// 3. Summarize any active conversations
/// 4. Flush all pending database writes
/// 5. Log: "Î© Omega shutting down gracefully"
///
/// Use tokio::signal::ctrl_c() for this.
```

### Init wizard improvement:

```rust
/// `omega init` should:
/// 1. Create ~/.omega/ directory
/// 2. Generate config.toml with sensible defaults
/// 3. Check if claude CLI is available
/// 4. Ask for Telegram bot token (paste prompt)
/// 5. Ask user to message @raw_data_bot for their user ID
/// 6. Write complete config.toml
/// 7. Run omega status to verify everything
/// 8. Print: "Î© Omega ready. Run 'omega start' to begin."
///
/// The entire init should take < 2 minutes for any user.
```

---

## 7. README â€” The First Impression

Rewrite README.md to be compelling. This is what people see first on GitHub.

```markdown
# Î© Omega

**Personal AI agent. Single binary. Your server. Your rules.**

Omega is a self-hosted AI agent written in Rust that connects your messaging apps
to AI backends. Talk to it on Telegram, it executes on your server.

Built as a lightweight, secure, and opinionated alternative to OpenClaw.

## What makes Omega different

| | Omega | OpenClaw |
|---|---|---|
| Language | Rust | JavaScript |
| Binary | Single static binary | Node.js + 430K lines |
| Setup time | 2 minutes | 30+ minutes |
| Claude Code | Zero-config, no API key | Not supported |
| Memory | Summarized + facts (25MB/year) | Raw storage (GB/year) |
| Security | Auth + sanitization + audit log | Community-reviewed skills |

## Quick Start

```bash
cargo install omega
omega init        # Interactive setup â€” 2 minutes
omega start       # Your agent is live
```

Then message your bot on Telegram. That's it.

## How It Works

```
You (Telegram) â†’ Omega (your server) â†’ Claude Code â†’ back to you
```

Every message is authenticated, sanitized, processed, stored in memory,
and audit-logged. The agent remembers your conversations and learns
your preferences over time.

## Commands

| Command | What it does |
|---|---|
| /status | Agent health and stats |
| /memory | Memory usage and counts |
| /history | Recent conversation summaries |
| /facts | What Omega knows about you |
| /forget | Clear current conversation |
| /help | List commands |

## Requirements

- Rust toolchain (for building)
- Claude Code CLI (authenticated)
- Telegram bot token (from @BotFather)

## Configuration

Copy `config.example.toml` to `config.toml`. The defaults work out of the box
with Claude Code. See the config file for all options.

## Architecture

Omega is a Cargo workspace with 6 crates:

- **omega-core** â€” Config, types, traits, error handling, sanitization
- **omega-providers** â€” AI backends (Claude Code, Anthropic, OpenAI, Ollama)
- **omega-channels** â€” Messaging platforms (Telegram, future: WhatsApp)
- **omega-memory** â€” SQLite-based persistent memory with summarization
- **omega-skills** â€” Plugin system (planned)
- **omega-sandbox** â€” Secure execution (planned)

## License

MIT OR Apache-2.0

## Author

Ivan Lozada â€” [@omega-cortex](https://github.com/omega-cortex)
```

---

## BUILD ORDER

1. **Memory enhancement**: migration, conversation summaries, facts extraction, context building with history
2. **Typing indicator + processing message**: user never wonders if bot is alive
3. **Built-in commands**: /status, /memory, /history, /facts, /forget, /help
4. **System prompt upgrade**: better prompt with facts and history included
5. **Startup self-check**: verify everything before accepting messages
6. **Graceful shutdown**: handle SIGTERM, summarize active conversations
7. **Retry logic**: exponential backoff on Telegram polling failures
8. **README rewrite**: compelling first impression
9. **Init wizard**: 2-minute setup for any user

Each step must compile, pass tests, and be committed individually.

The goal: after this phase, Omega is not just functional â€” it's **delightful** to use. Every interaction feels like talking to an assistant that knows you and never fails.
